## 12.2
只要进程被终止，内核都会关闭所有打开的文件并释放它们的内存资源
PS：跟waitpid无关

## 12.4
需要将输入参数（代表要读的集合）和输出参数（代表准备好的集合）区分开

## 12.10
一开始有10个写者，然后来了个读者
如果V操作一直在选择重启写者的线程，那就会导致读者饥饿

## 12.14
A. 创建N个元素的数组
B. 数组空间要到全部结束才会被系统释放
PS: 书给出的正确答案是直接传值而不是传指针。优点降低了开销，缺点是假设了指针至少和int一样大，在过去或今后系统可能就不一定了。这里有点鸡蛋挑骨头

## 12.15
B. 会
C. t=1

## 12.19
首先中文版题目第一行就写错了，应该是“因为写者在离开它的临界区”
https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.19/ 答案可能有问题
正确答案参考 https://zhuanlan.zhihu.com/p/351012714
一个诀窍，题目说的是当写者离开它的临界区的时候
就思考writer还没执行V(&w)时，如果有多个读者，多个写者，分别会卡在什么步骤
然后执行V(&w)，就假设内核坏心眼，就是铁了心卡着读者，这样可以验证答案是否正确

## 12.20
我以为题目的意思是
  当有N个读者正在并发执行时，来了第N+1个读者和一个写者，要如何才能让第N+1个读者或写者等待前N个读者结束再公平竞争机会
然后我做不出来，看了下dreamanddead老兄的答案，他更简单暴力，什么N个读者全都是放屁，一次只能执行一个读者或写者
不知道题目到底是图个啥

## 12.21
TODO
不会做，看别的答案感觉还是不对劲
先放下，看看有没有其他的书给个参考答案。

## 12.22
实际上echoservers.c示例就是答案，所以这题目到底是图个啥

## 12.23
看dreamanddead老兄的意思，如果echoclient在Rio_writen之后不执行Close函数直接exit(0)(不确定这里是不是对应书里提到的发送部分行)，服务端就会接到Rio_readlineb error: Connection reset by peer的报错
我这里试了下，确实能重现，但是往往需要echoclient执行几遍才能看到，具体原因不明
假设dreamanddead老兄对题目的理解是对的，那么他给出的解决方法其实就是显式处理问题，而不是靠Rio包内的判断错误逻辑

## 12.25
是线程安全 但不是可重入的

## 12.26
因为没用过gethostbyname，所以懒得做了。
不过可以复习下什么叫加锁-复制技术

## 12.27
参见书里的10.11节

## 12.30
感觉题目质量不行啊，`a<b<c`是什么鬼，看都看不懂

## 12.31
