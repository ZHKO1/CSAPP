仅挑重要的题
## 6.36
这道题的精华在于C,D,E小题
C小题实际验证了解决冲突不命中的方案
  如果缓存大小是512字节，直接映射，不命中率会是100%，显然这就是冲突不命中
  然而改为两路组相联，就算缓存大小不变，却能解决冲突不命中的问题了
D小题需要考虑到如果块大小没变，不命中率不会有改善
E小题明确提到块大小，所以能改善不命中率
## 6.37
这道题再次考察了对冲突不命中本质的理解
高速缓存4KB，直接映射，块大小16字节
  得到 C=4*1024 S=256 B=16 s=8 b=4
  显然此高速缓存有256个块，这里编号为块0~块255
当N=64，sumB为何会发生冲突不命中？
  首先计算数组a的每个元素，看看如果分配到高速缓存，会对应哪个块号
  i=0~15 如下所示，16~31 32~47 48~63 也是同样的对应逻辑
  0  0  0  0  1  1  1  1  2  2  2  2  .... 15 15 15 15
  16 16 16 16 17 17 17 17 18 18 18 18 .... 31 31 31 31
  ...
  240         241          242        .... 255
  以j=0为例
    命中块号为 0 16 32 48 ... 240 如此循环4次
    可以看到一共64次，只用到了高速缓存16个块，其他块（256-16）只能干瞪眼
  所以这就是冲突不命中，导致sumB内循环不命中率100%
当N=60，sumB又会如何？
  再次看看数组a的每个元素会对应哪个块号
  0   1   2   3   .... 14      第0行
  15  16  17  18  .... 29      第1行
  30  31  32  33  .... 44      第2行
  ....
  240 241 242 243 .... 254     第16行
  255 0   1   2   .... 13      第17行
  14  15  16  17  .... 28      第18行
  29  30  31  32  .... 43      第19行
  ....
  239 240 241 242 .... 253     第33行
  254 255 0   1   .... 12      第34行
  13  14  15  16  .... 27      第35行
  28  29  30  31  .... 42      第36行
  ....
  238 239 240 241 .... 252     第50行
  253 254 255 0   .... 11      第51行
  12  13  14  15  .... 26      第52行
  27  28  29  30  .... 41      第53行
  ....
  117 118 119 120 .... 131     第59行
  这里可以看到当j=0时, i=0~59时的块号是不重复的，占据了高速缓存上的60个块，也就是没有冲突不命中，这里显然是都没命中
  然后当j=1~3时，全都命中
  当j=4~59，同上
  所以不命中率只有25%，sum4也同理得出25%
这里也看到有个大佬也为此写了代码来验证，请参见6.37_N60.c和6.37_N64.c
## 6.45
参见代码
这里学习如何在C语言里覆写随机数，以及计时
## 6.46
参见代码